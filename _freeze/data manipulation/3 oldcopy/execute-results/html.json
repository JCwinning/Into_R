{
  "hash": "a3b98006a0da5f67dea8073f6598c8a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Manipulation with tidyverse\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: true\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\n\n![](images/ggplot_hive.jpg){width=\"600\"}\n\n`dplyr` is a core tidyverse package that provides a consistent and intuitive grammar for data manipulation.\n\n![](images/logo.png){width=\"231\"}\n\n# Load Packages and Data\n\nFirst, we load the `tidyverse` suite of packages.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\nWe will use the built-in `mtcars` dataset for these examples. For simplicity, we select a few columns and convert the row names to a proper column called `car_name`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nsmall_mtcars <- mtcars %>% \n  select(cyl, mpg, hp) %>% \n  head()\n\nsmall_mtcars <- rownames_to_column(small_mtcars, var = \"car_name\")\n\nsmall_mtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1         Mazda RX4   6 21.0 110\n2     Mazda RX4 Wag   6 21.0 110\n3        Datsun 710   4 22.8  93\n4    Hornet 4 Drive   6 21.4 110\n5 Hornet Sportabout   8 18.7 175\n6           Valiant   6 18.1 105\n```\n\n\n:::\n:::\n\n# Data Manipulation with dplyr\n\n## Select Columns\n\n### Get Column Names\n\nThe `names()` function returns a character vector of the column names in a data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(small_mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_name\" \"cyl\"      \"mpg\"      \"hp\"      \n```\n\n\n:::\n:::\n\n### Select by Name\n\nThe `select()` verb chooses columns by name.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% select(cyl, mpg, hp) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl  mpg  hp\n1   6 21.0 110\n2   6 21.0 110\n3   4 22.8  93\n4   6 21.4 110\n5   8 18.7 175\n6   6 18.1 105\n```\n\n\n:::\n:::\n\n### Select with Helpers\n\n`select()` can be used with helper functions like `contains()` to choose columns based on patterns in their names.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% select(contains(\"p\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mpg  hp\n1 21.0 110\n2 21.0 110\n3 22.8  93\n4 21.4 110\n5 18.7 175\n6 18.1 105\n```\n\n\n:::\n:::\n\n### Select by Index\n\nYou can also select columns by their position.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% select(1, 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl\n1         Mazda RX4   6\n2     Mazda RX4 Wag   6\n3        Datsun 710   4\n4    Hornet 4 Drive   6\n5 Hornet Sportabout   8\n6           Valiant   6\n```\n\n\n:::\n:::\n\n### Drop Columns\n\nUse the `-` sign to deselect or drop columns.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% select(-cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg  hp\n1         Mazda RX4 21.0 110\n2     Mazda RX4 Wag 21.0 110\n3        Datsun 710 22.8  93\n4    Hornet 4 Drive 21.4 110\n5 Hornet Sportabout 18.7 175\n6           Valiant 18.1 105\n```\n\n\n:::\n:::\n\n## Rename Columns\n\nThe `rename()` verb changes the name of a column.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% rename(new_cyl = cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name new_cyl  mpg  hp\n1         Mazda RX4       6 21.0 110\n2     Mazda RX4 Wag       6 21.0 110\n3        Datsun 710       4 22.8  93\n4    Hornet 4 Drive       6 21.4 110\n5 Hornet Sportabout       8 18.7 175\n6           Valiant       6 18.1 105\n```\n\n\n:::\n:::\n\n## Create Columns\n\n### Mutate\n\n`mutate()` adds new columns or transforms existing ones.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% mutate(new_cyl = cyl + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp new_cyl\n1         Mazda RX4   6 21.0 110       7\n2     Mazda RX4 Wag   6 21.0 110       7\n3        Datsun 710   4 22.8  93       5\n4    Hornet 4 Drive   6 21.4 110       7\n5 Hornet Sportabout   8 18.7 175       9\n6           Valiant   6 18.1 105       7\n```\n\n\n:::\n:::\n\n### Conditional Creation with `if_else`\n\n`if_else()` is a vectorized conditional statement, useful inside `mutate()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% mutate(new_cly_group = if_else(cyl > 6, 'big', 'small'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp new_cly_group\n1         Mazda RX4   6 21.0 110         small\n2     Mazda RX4 Wag   6 21.0 110         small\n3        Datsun 710   4 22.8  93         small\n4    Hornet 4 Drive   6 21.4 110         small\n5 Hornet Sportabout   8 18.7 175           big\n6           Valiant   6 18.1 105         small\n```\n\n\n:::\n:::\n\n### Conditional Creation with `case_when`\n\n`case_when()` is useful for multiple conditions (like a multi-part if-else statement).\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% mutate(cly_group = case_when(\n    cyl > 6 ~ \"very big\",\n    cyl > 4 ~ \"big\",\n    TRUE ~ \"other\"\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp cly_group\n1         Mazda RX4   6 21.0 110       big\n2     Mazda RX4 Wag   6 21.0 110       big\n3        Datsun 710   4 22.8  93     other\n4    Hornet 4 Drive   6 21.4 110       big\n5 Hornet Sportabout   8 18.7 175  very big\n6           Valiant   6 18.1 105       big\n```\n\n\n:::\n:::\n\n### Transmute\n\n`transmute()` is like `mutate()`, but it drops all other columns, keeping only the newly created ones.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% transmute(new_cyl = cyl + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  new_cyl\n1       7\n2       7\n3       5\n4       7\n5       9\n6       7\n```\n\n\n:::\n:::\n\n## Filter Rows\n\n`filter()` subsets rows based on logical conditions.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% filter(cyl > 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1         Mazda RX4   6 21.0 110\n2     Mazda RX4 Wag   6 21.0 110\n3    Hornet 4 Drive   6 21.4 110\n4 Hornet Sportabout   8 18.7 175\n5           Valiant   6 18.1 105\n```\n\n\n:::\n:::\n\n### Filters with AND conditions\n\nSeparate conditions with a comma for an AND relationship.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% filter(cyl > 5, mpg > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        car_name cyl  mpg  hp\n1      Mazda RX4   6 21.0 110\n2  Mazda RX4 Wag   6 21.0 110\n3 Hornet 4 Drive   6 21.4 110\n```\n\n\n:::\n:::\n\n### Filters with OR conditions\n\nUse the `|` operator for an OR relationship.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% filter(cyl > 5 | mpg > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1         Mazda RX4   6 21.0 110\n2     Mazda RX4 Wag   6 21.0 110\n3        Datsun 710   4 22.8  93\n4    Hornet 4 Drive   6 21.4 110\n5 Hornet Sportabout   8 18.7 175\n6           Valiant   6 18.1 105\n```\n\n\n:::\n:::\n\n### Filter Rows by Index with `slice`\n\n`slice()` allows you to select rows by their position.\n\nSelect the 5th row:\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% slice(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1 Hornet Sportabout   8 18.7 175\n```\n\n\n:::\n:::\n\nSelect a random sample of rows:\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% sample_n(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1 Hornet Sportabout   8 18.7 175\n2         Mazda RX4   6 21.0 110\n3        Datsun 710   4 22.8  93\n```\n\n\n:::\n:::\n\n## Handle Missing Data\n\nLet's create a sample data frame with missing values (`NA`).\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_df <- data.frame(\n  x = c(1, 2, NA, 4),\n  y = c(\"a\", NA, \"c\", \"d\")\n)\n```\n:::\n\n### Find Missing Data\n\n`is.na()` returns a logical vector indicating which values are missing.\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(missing_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         x     y\n[1,] FALSE FALSE\n[2,] FALSE  TRUE\n[3,]  TRUE FALSE\n[4,] FALSE FALSE\n```\n\n\n:::\n:::\n\n### Filter Out Missing Data\n\nYou can use `filter()` with `!is.na()` to remove rows with missing values in a specific column.\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_df %>% filter(!is.na(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x y\n1  1 a\n2 NA c\n3  4 d\n```\n\n\n:::\n:::\n\n`tidyr::drop_na()` removes rows with any missing values.\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_df %>% drop_na()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 a\n2 4 d\n```\n\n\n:::\n:::\n\n## Group and Summarize Data\n\n`group_by()` groups the data by one or more variables. `summarise()` then collapses each group into a single-row summary.\n\n### Common Summary Functions\n\nCalculate the mean, min, max, and sum of `mpg` for each cylinder group.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(\n    avg_mpg = mean(mpg),\n    min_mpg = min(mpg),\n    max_mpg = max(mpg),\n    sum_mpg = sum(mpg)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n    cyl avg_mpg min_mpg max_mpg sum_mpg\n  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1     4    26.7    21.4    33.9    293.\n2     6    19.7    17.8    21.4    138.\n3     8    15.1    10.4    19.2    211.\n```\n\n\n:::\n:::\n\n### Count Records\n\n`n()` counts the total number of records in each group, while `n_distinct()` counts the number of unique values.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(\n    n_mpg = n(),\n    distinct_n_mpg = n_distinct(mpg)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n    cyl n_mpg distinct_n_mpg\n  <dbl> <int>          <int>\n1     4    11              9\n2     6     7              6\n3     8    14             12\n```\n\n\n:::\n:::\n\n## Window Functions\n\nWindow functions are functions that operate on a \"window\" of data (e.g., within a group) but, unlike `summarise()`, they return a value for every row.\n\n### Ranking with `row_number`\n\n`row_number()` assigns a unique rank to each row within a group.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% \n  group_by(cyl) %>% \n  mutate(rank = row_number(desc(mpg))) %>% \n  select(cyl, mpg, rank)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n# Groups:   cyl [3]\n    cyl   mpg  rank\n  <dbl> <dbl> <int>\n1     6  21       2\n2     6  21       3\n3     4  22.8     1\n4     6  21.4     1\n5     8  18.7     1\n6     6  18.1     4\n```\n\n\n:::\n:::\n\n### Accessing Previous/Next Values with `lag` and `lead`\n\n`lag()` and `lead()` are useful for comparing a value to its predecessor or successor.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% \n  select(cyl, mpg) %>% \n  mutate(mpg_previous = lag(mpg, n = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl  mpg mpg_previous\n1   6 21.0           NA\n2   6 21.0         21.0\n3   4 22.8         21.0\n4   6 21.4         22.8\n5   8 18.7         21.4\n6   6 18.1         18.7\n```\n\n\n:::\n:::\n\n### Cumulative Summaries\n\n`cumsum()` calculates the cumulative sum.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% \n  select(cyl, mpg) %>% \n  mutate(mpg_running_total = cumsum(mpg))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl  mpg mpg_running_total\n1   6 21.0              21.0\n2   6 21.0              42.0\n3   4 22.8              64.8\n4   6 21.4              86.2\n5   8 18.7             104.9\n6   6 18.1             123.0\n```\n\n\n:::\n:::\n\n## Order Rows\n\n`arrange()` sorts the rows of a data frame by one or more columns.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% arrange(cyl) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1        Datsun 710   4 22.8  93\n2         Mazda RX4   6 21.0 110\n3     Mazda RX4 Wag   6 21.0 110\n4    Hornet 4 Drive   6 21.4 110\n5           Valiant   6 18.1 105\n6 Hornet Sportabout   8 18.7 175\n```\n\n\n:::\n:::\n\nSort in descending order using `desc()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_mtcars %>% arrange(desc(cyl))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name cyl  mpg  hp\n1 Hornet Sportabout   8 18.7 175\n2         Mazda RX4   6 21.0 110\n3     Mazda RX4 Wag   6 21.0 110\n4    Hornet 4 Drive   6 21.4 110\n5           Valiant   6 18.1 105\n6        Datsun 710   4 22.8  93\n```\n\n\n:::\n:::\n\n## Join Tables\n\nFirst, let's create two small data frames to demonstrate joins.\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data = small_mtcars %>% slice(1:3)\nright_data = small_mtcars %>% slice(2:4)\n```\n:::\n\n### Inner Join\n\n`inner_join()` returns only the rows where the key exists in both tables.\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% inner_join(right_data, by = \"car_name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       car_name cyl.x mpg.x hp.x cyl.y mpg.y hp.y\n1 Mazda RX4 Wag     6  21.0  110     6  21.0  110\n2    Datsun 710     4  22.8   93     4  22.8   93\n```\n\n\n:::\n:::\n\n### Left Join\n\n`left_join()` returns all rows from the left table, and matching rows from the right table.\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% left_join(right_data, by = \"car_name\", suffix = c(\"_l\", \"_r\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       car_name cyl_l mpg_l hp_l cyl_r mpg_r hp_r\n1     Mazda RX4     6  21.0  110    NA    NA   NA\n2 Mazda RX4 Wag     6  21.0  110     6  21.0  110\n3    Datsun 710     4  22.8   93     4  22.8   93\n```\n\n\n:::\n:::\n\n### Anti Join\n\n`anti_join()` returns all rows from the left table that do not have a match in the right table.\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_data %>% anti_join(right_data, by = \"car_name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   car_name cyl mpg  hp\n1 Mazda RX4   6  21 110\n```\n\n\n:::\n:::\n\n## Reshape Tables\n\nReshaping data involves converting it between \"wide\" and \"long\" formats.\n\n::: {.cell}\n\n```{.r .cell-code}\nolddata_wide <- read.table(header = TRUE, text = '\n subject sex control cond1 cond2\n       1   M     7.9  12.3  10.7\n       2   F     6.3  10.6  11.1\n       3   F     9.5  13.1  13.8\n       4   M    11.5  13.4  12.9\n')\n```\n:::\n\n### Wide to Long with `pivot_longer`\n\n`pivot_longer()` makes data \"longer\" by gathering multiple columns into key-value pairs.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_long = olddata_wide %>% \n  pivot_longer(!c(subject, sex), names_to = 'condition', values_to = 'measurement')\n\ndata_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   subject sex   condition measurement\n     <int> <chr> <chr>           <dbl>\n 1       1 M     control           7.9\n 2       1 M     cond1            12.3\n 3       1 M     cond2            10.7\n 4       2 F     control           6.3\n 5       2 F     cond1            10.6\n 6       2 F     cond2            11.1\n 7       3 F     control           9.5\n 8       3 F     cond1            13.1\n 9       3 F     cond2            13.8\n10       4 M     control          11.5\n11       4 M     cond1            13.4\n12       4 M     cond2            12.9\n```\n\n\n:::\n:::\n\n### Long to Wide with `pivot_wider`\n\n`pivot_wider()` does the opposite, making data \"wider\" by spreading a key-value pair into multiple columns.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_wide = data_long %>% \n  pivot_wider(names_from = condition, values_from = measurement)\n\ndata_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  subject sex   control cond1 cond2\n    <int> <chr>   <dbl> <dbl> <dbl>\n1       1 M         7.9  12.3  10.7\n2       2 F         6.3  10.6  11.1\n3       3 F         9.5  13.1  13.8\n4       4 M        11.5  13.4  12.9\n```\n\n\n:::\n:::\n\n# String Manipulation with stringr\n\n`stringr` provides a consistent and user-friendly interface for common string operations.\n\n![](images/logo-01.png)\n\n## String Operations\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"I like horses.\"\nstr_length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_upper(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I LIKE HORSES.\"\n```\n\n\n:::\n:::\n\n## Pattern Matching\n\n`str_detect()` checks for the presence of a pattern and returns a logical vector.\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list = c('abc', 'bbc', 'apple', 'bbaa', 'cc')\nword_list %>% str_detect('a')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n`str_replace_all()` replaces all matches of a pattern with a new string.\n\n::: {.cell}\n\n```{.r .cell-code}\ntext001 = \"abcb\"\ntext001 %>% str_replace_all('b', '1')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a1c1\"\n```\n\n\n:::\n:::\n\n## Splitting Strings\n\n`tidyr::separate()` splits a column into multiple new columns based on a delimiter.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_word <- data.frame(word = c('a-b', '1-c', 'c-c'))\ndf_word %>% separate(word, c('col1', 'col2'), '-')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  col1 col2\n1    a    b\n2    1    c\n3    c    c\n```\n\n\n:::\n:::\n\n## Extracting Substrings\n\n`str_extract()` pulls out the first match of a regular expression.\n\n::: {.cell}\n\n```{.r .cell-code}\ntrx = 'abc1993 ccc'\ntrx %>% str_extract(\"(\\\\d)+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1993\"\n```\n\n\n:::\n:::\n\n# Date and Time Manipulation with lubridate\n\n`lubridate` simplifies working with dates and times in R.\n\n![](images/logo-02.png)\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n:::\n\n## Parsing Dates\n\n`lubridate` provides helper functions like `ymd()` to parse strings into dates reliably.\n\n::: {.cell}\n\n```{.r .cell-code}\ndate3 = ymd('2023-01-01')\nclass(date3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n## Date Components\n\nEasily extract components like year, month, or day from a date object.\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_time = now()\nyear(now_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2025\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth(now_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwday(now_time, label = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Tue\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n```\n\n\n:::\n:::\n\n## Date Arithmetic\n\nPerform calculations with date objects.\n\n::: {.cell}\n\n```{.r .cell-code}\nday1 = ymd('2022-01-01')\nday2 = ymd('2023-02-03')\n\n# Calculate the time difference\ninterval(day1, day2) %/% months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13\n```\n\n\n:::\n:::\n\n\n# dataframe to other data format\n\n## dataframe to vector\n\n::: {.cell}\n\n```{.r .cell-code}\ndata=small_mtcars$cyl\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 6 4 6 8 6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n## dataframe to matrix\n\n::: {.cell}\n\n```{.r .cell-code}\ndata=data.matrix(small_mtcars)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     car_name cyl  mpg  hp\n[1,]        4   6 21.0 110\n[2,]        5   6 21.0 110\n[3,]        1   4 22.8  93\n[4,]        2   6 21.4 110\n[5,]        3   8 18.7 175\n[6,]        6   6 18.1 105\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n## dataframe to list\n\n::: {.cell}\n\n```{.r .cell-code}\ndata=as.list(small_mtcars)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$car_name\n[1] \"Mazda RX4\"         \"Mazda RX4 Wag\"     \"Datsun 710\"       \n[4] \"Hornet 4 Drive\"    \"Hornet Sportabout\" \"Valiant\"          \n\n$cyl\n[1] 6 6 4 6 8 6\n\n$mpg\n[1] 21.0 21.0 22.8 21.4 18.7 18.1\n\n$hp\n[1] 110 110  93 110 175 105\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n# Reference:\n\nhttps://dplyr.tidyverse.org/\n\nhttps://stringr.tidyverse.org/\n\nhttps://lubridate.tidyverse.org/\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}