{
  "hash": "7fbe0ae3c49fbe514fc3c8421dcba130",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Probability\"\nauthor: \"Tony D\"\n\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: true\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n    code-copy: true\n---\n\nProbability is the branch of mathematics concerning events and numerical descriptions of how likely they are to occur. The probability of an event is a number between 0 and 1; the larger the probability, the more likely an event is to occur.\n\n![](images/images-01.jpg){width=\"350\"}\n\n# Random Numbers\n\n## Draw 10 numbers from 1 to 10\n\nThe `sample()` function is used to take a random sample from a vector. Here, we are sampling 10 numbers from the sequence 1 to 10. `replace = TRUE` means that after a number is drawn, it is put back into the pool and can be drawn again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = sample(1:10, 10, replace = TRUE)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  9  2  5  4  7  7  4 10  6  1\n```\n\n\n:::\n:::\n\n\nThis code creates a frequency table to show how many times each number was drawn. With a small sample size, the distribution might not be perfectly even.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(table(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a Freq\n1  1    1\n2  2    1\n3  4    2\n4  5    1\n5  6    1\n6  7    2\n7  9    1\n8 10    1\n```\n\n\n:::\n:::\n\n\n## Draw 10,000 numbers from 1 to 10\n\nBy increasing the sample size to 10,000, the law of large numbers suggests that the frequency of each number will be much closer to 10%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = sample(1:10, 10000, replace = TRUE)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(table(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a Freq\n1   1  990\n2   2 1001\n3   3  987\n4   4 1013\n5   5  961\n6   6 1089\n7   7 1032\n8   8  991\n9   9  984\n10 10  952\n```\n\n\n:::\n:::\n\n\n# Permutations and Combinations\n\n![](images/clipboard-2817248623.png)\n\n## Permutations (order matters): choosing 2 numbers from 4\n\nThe `gtools::permutations()` function calculates the number of ways to choose and arrange `r` items from a set of `n` items. The formula is n! / (n-r)!.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gtools)\nall_num = 4\nchoose = 2\n\nres <- permutations(n = all_num, r = choose, v = 1:all_num)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2]\n [1,]    1    2\n [2,]    1    3\n [3,]    1    4\n [4,]    2    1\n [5,]    2    3\n [6,]    2    4\n [7,]    3    1\n [8,]    3    2\n [9,]    3    4\n[10,]    4    1\n[11,]    4    2\n[12,]    4    3\n```\n\n\n:::\n:::\n\n\nThe number of permutations is 12.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(nrow(res))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\nThis can be calculated manually using the formula 4! / (4-2)!.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4) / factorial(4 - 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n## Combinations (order does not matter): choosing 2 numbers from 4\n\nThe `gtools::combinations()` function calculates the number of ways to choose `r` items from a set of `n` items, where order does not matter. The formula is n! / ((n-r)! * r!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gtools)\nall_num = 4\nchoose = 2\n\nres <- combinations(n = all_num, r = choose, v = 1:all_num)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    1    3\n[3,]    1    4\n[4,]    2    3\n[5,]    2    4\n[6,]    3    4\n```\n\n\n:::\n:::\n\n\nThe number of combinations is 6.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(nrow(res))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nThis can be calculated manually using the formula 4! / ((4-2)! * 2!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4) / (factorial(4 - 2) * factorial(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n# Conditional Probability\n\n**Problem**: The probability of any single person snoring is 20%. If there are 4 people in a room, what is the probability that at least one person snores?\n\n\n::: {.cell}\n\n```{.r .cell-code}\np = 0.2\nn = 4\n```\n:::\n\n\n## Solution 1: P(at least one) = P(1 snoring) + P(2 snoring) + P(3 snoring) + P(4 snoring)\n\nThis method calculates the probability of each case (1, 2, 3, or 4 people snoring) and adds them together.\n\n### 0 snoring\n\n\n::: {.cell}\n\n```{.r .cell-code}\np0 = (0.8 * 0.8 * 0.8 * 0.8)\np0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4096\n```\n\n\n:::\n:::\n\n\n### 1 snoring\n\nThere are 4 possible ways for exactly one person to snore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = (0.2 * 0.8 * 0.8 * 0.8) * 4\np1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4096\n```\n\n\n:::\n:::\n\n\n### 2 snoring\n\nThere are C(4,2) = 6 ways for exactly two people to snore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4) / (factorial(4 - 2) * factorial(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 = (0.2 * 0.2 * 0.8 * 0.8) * 6\np2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1536\n```\n\n\n:::\n:::\n\n\n### 3 snoring\n\nThere are C(4,3) = 4 ways for exactly three people to snore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4) / (factorial(4 - 3) * factorial(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np3 = (0.2 * 0.2 * 0.2 * 0.8) * 4\np3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0256\n```\n\n\n:::\n:::\n\n\n### 4 snoring\n\n\n::: {.cell}\n\n```{.r .cell-code}\np4 = (0.2 * 0.2 * 0.2 * 0.2)\np4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0016\n```\n\n\n:::\n:::\n\n\n### Total probability of at least one person snoring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nP_at_least_one = p1 + p2 + p3 + p4\nP_at_least_one\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5904\n```\n\n\n:::\n:::\n\n\n## Solution 2: P(at least one) = 1 - P(no one snoring)\n\nThis is a more direct method. The complement of \"at least one\" is \"none\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nP_at_least_one2 = 1 - (0.8^4)\nP_at_least_one2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5904\n```\n\n\n:::\n:::\n\n\n# Derangement Problem\n\nA derangement is a permutation of the elements of a set, such that no element appears in its original position.\n\n## Question 1: What is the probability of choosing 4 numbers from 4 and getting 0 correct (all wrong)?\n\nThe total number of permutations is 4! = 24.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24\n```\n\n\n:::\n:::\n\n\nThe number of derangements D(n) can be approximated by `round(n!/e)`. For n=4, this is D(4) = 9.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne = exp(1) # Use the built-in constant for e\nD_4 = round(factorial(4) / e)\nD_4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nThe probability of a complete derangement is the number of derangements divided by the total number of permutations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQ1 = D_4 / factorial(4)\nQ1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.375\n```\n\n\n:::\n:::\n\n\n## Question 2: What is the probability of choosing 4 numbers from 4 and getting exactly 1 correct?\n\nFirst, choose 1 number to be correct (C(4,1) = 4 ways). Then, find the number of derangements for the remaining 3 numbers (D(3) = 2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD_3 = round(factorial(3) / e)\nD_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nThe total number of ways to get exactly 1 correct is C(4,1) * D(3) = 4 * 2 = 8.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQ2 = (4 * D_3) / factorial(4)\nQ2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3333333\n```\n\n\n:::\n:::\n\n\n## Question 3: What is the probability of choosing 4 numbers from 4 and getting exactly 2 correct?\n\nFirst, choose 2 numbers to be correct (C(4,2) = 6 ways). Then, find the number of derangements for the remaining 2 numbers (D(2) = 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD_2 = round(factorial(2) / e)\nC_4_2 = factorial(4) / (factorial(2) * factorial(2))\nQ3 = (C_4_2 * D_2) / factorial(4)\nQ3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.25\n```\n\n\n:::\n:::\n\n\n## Question 4: What is the probability of choosing 4 numbers from 4 and getting exactly 3 correct?\n\nThis is impossible. If 3 numbers are in their correct positions, the 4th number must also be in its correct position. The number of derangements of 1 item is D(1) = 0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQ4 = 0\nQ4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n## Question 5: What is the probability of choosing 4 numbers from 4 and getting all 4 correct?\n\nThere is only one way for this to happen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQ5 = 1 / factorial(4)\nQ5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.04166667\n```\n\n\n:::\n:::\n\n\nThe sum of all probabilities should be 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQ1 + Q2 + Q3 + Q4 + Q5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n# Distributions\n\n## Binomial Distribution\n\nThe binomial distribution models the number of successes in a fixed number of independent trials, each with a binary outcome (success/failure).\n\n### Probability Mass Function (PMF)\n\nIn R, the `dbinom` function calculates the probability of getting exactly `x` successes. While this is technically a PMF for a discrete distribution, R uses the `d` prefix convention for both PDF (continuous) and PMF (discrete).\n\nProbability of exactly 1 person snoring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 4 # number of trials (people)\np = 0.2 # probability of success (snoring)\n\ndbinom(x = 1, size = n, prob = p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4096\n```\n\n\n:::\n:::\n\n\nProbabilities for 0, 1, 2, 3, or 4 people snoring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbinom(x = c(0, 1, 2, 3, 4), size = n, prob = p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4096 0.4096 0.1536 0.0256 0.0016\n```\n\n\n:::\n:::\n\n\n### Cumulative Distribution Function (CDF)\n\nThe `pbinom` function calculates the cumulative probability of getting `q` or fewer successes.\n\nProbability of 1 or fewer people snoring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbinom(q = 1, size = n, prob = p, lower.tail = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8192\n```\n\n\n:::\n:::\n\n\n### Random Number Generation\n\nThe `rbinom` function generates random numbers from a binomial distribution.\n\nGenerate 10,000 random values from this distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = rbinom(10000, size = 4, prob = 0.2)\ntable(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na\n   0    1    2    3    4 \n4071 4166 1490  250   23 \n```\n\n\n:::\n:::\n\n\n## Normal Distribution (Gaussian Distribution)\n\nA continuous probability distribution characterized by a bell-shaped curve. It is defined by its mean (μ) and standard deviation (σ).\n\n### R Functions\n\n- `dnorm`: Density function (PDF)\n- `pnorm`: Cumulative distribution function (CDF)\n- `qnorm`: Quantile function (inverse CDF)\n- `rnorm`: Random number generation\n\n### Probability Density Function (PDF)\n\nCalculates the height of the probability density function at a given point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndnorm(0, mean = 1, sd = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1760327\n```\n\n\n:::\n:::\n\n\n### Cumulative Distribution Function (CDF)\n\nCalculates the area under the curve to the left of a given value (the probability of observing a value less than or equal to `q`).\n\nProbability of observing a value <= 70 from a N(75, 5) distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(q = 70, mean = 75, sd = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1586553\n```\n\n\n:::\n:::\n\n\n### Quantile Function\n\nFinds the value `x` such that P(X <= x) = p. It is the inverse of the CDF.\n\nFind the 25th percentile (Q1) of a N(75, 5) distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(p = 0.25, mean = 75, sd = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71.62755\n```\n\n\n:::\n:::\n\n\n### Random Number Generation\n\nGenerate 1,000 random numbers from a N(75, 5) distribution and plot a histogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnd = rnorm(n = 1000, mean = 75, sd = 5)\nhist(nd)\n```\n\n::: {.cell-output-display}\n![](2-probability_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n### Checking for Normality\n\nIt's often important to check if a dataset follows a normal distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnd_data = rnorm(n = 1000, mean = 0, sd = 2)\nnon_nd_data = rpois(n = 1000, lambda = 5) # Poisson data is not normal\n```\n:::\n\n\n#### Method 1: Histogram\nA bell-shaped histogram suggests normality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nhist(nd_data, col = 'steelblue', main = 'Normal')\nhist(non_nd_data, col = 'darkred', main = 'Non-normal')\n```\n\n::: {.cell-output-display}\n![](2-probability_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n#### Method 2: Q-Q Plot\nIf the data is normal, the points on a Q-Q plot will fall closely along the straight line.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nqqnorm(nd_data, main = 'Normal')\nqqline(nd_data)\nqqnorm(non_nd_data, main = 'Non-normal')\nqqline(non_nd_data)\n```\n\n::: {.cell-output-display}\n![](2-probability_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n#### Method 3: Shapiro-Wilk Test\nA statistical test for normality. The null hypothesis (H0) is that the data is normally distributed.\n\nIf the p-value is > 0.05, we do not reject the null hypothesis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(nd_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  nd_data\nW = 0.99878, p-value = 0.7416\n```\n\n\n:::\n:::\n\n\nIf the p-value is < 0.05, we reject the null hypothesis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(non_nd_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  non_nd_data\nW = 0.97058, p-value = 2.364e-13\n```\n\n\n:::\n:::\n\n\n## Other Key Distributions\n\n- **Student's t-distribution**: Used for inference about the mean of a normally distributed population when the standard deviation is unknown.\n- **F-distribution**: Used in ANOVA to compare the means of multiple groups.\n- **Chi-square distribution**: Used in goodness-of-fit tests and tests of independence.\n- **Poisson Distribution**: Models the number of events occurring in a fixed interval of time or space.\n\n# References\n\n## Online Resources\n\n### Tutorials and Guides\n- [Wolfgang Huber - Biostatistics Course](https://www.huber.embl.de/users/kaspar/biostat_2021/2-demo.html)\n- [Scribbr - Probability Distributions Guide](https://www.scribbr.com/statistics/probability-distributions/)\n- [Statology - Test for Normality in R](https://www.statology.org/test-for-normality-in-r/)\n\n### Video Tutorials\n- [Permutations and Combinations](https://www.youtube.com/watch?v=peEsXbdMY_4)\n- [Conditional Probability](https://www.youtube.com/watch?v=ETd-jPhI_tE)\n- [Binomial Distribution](https://www.youtube.com/watch?v=kvmSAXhX9Hs)\n- [Normal Distribution](https://www.youtube.com/watch?v=RlhnNbPZC0A)\n- [Understanding Distributions](https://www.youtube.com/watch?v=X5NXDK6AVtU)\n- [Probability Theory](https://www.youtube.com/watch?v=Q_pO9NzWxPY)\n\n### Mathematical Concepts\n- [Wikipedia - Derangement](https://en.wikipedia.org/wiki/Derangement)\n\n## Books\n- **Introduction to Probability** by Joseph K. Blitzstein and Jessica Hwang\n- **Probability and Statistics for Data Science** by Norman Matloff\n- **The Art of Statistics** by David Spiegelhalter\n\n## R Documentation\n- [R Stats Package](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Distributions.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{.details summary=\"sessionInfo()\"}\nR version 4.5.1 (2025-06-13)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Tahoe 26.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] gtools_3.9.5\n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.5.1    fastmap_1.2.0     cli_3.6.5        \n [5] tools_4.5.1       htmltools_0.5.8.1 rstudioapi_0.17.1 yaml_2.3.10      \n [9] rmarkdown_2.29    knitr_1.50        jsonlite_2.0.0    xfun_0.52        \n[13] digest_0.6.37     rlang_1.1.6       evaluate_1.0.4   \n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "2-probability_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}